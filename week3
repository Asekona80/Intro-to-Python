Data structure Day 1 

.Function Definition: 

`fib(n)` is defined to print the Fibonacci series up to the given boundary `n`. 

`fib2(n)` is defined to return a list containing the Fibonacci series up to `n`. 

 

Fibonacci Calculation: 

The Fibonacci series is generated using two variables, `a` and `b`, initialized to 0 and 1. 

The series is calculated in a loop using the formula `a, b = b, a + b`. 

 

Printing vs. Returning: 

`fib(n)` prints the series while `fib2(n)` returns it as a list. 

Function Calls: 

`fib(2000)` and `fib(0)` are examples of function calls. 

`fib2(100)` returns the Fibonacci series up to 100 and stores it in the variable `f100`. 

 

Return Statement: 

The `return` statement is used to return a value from a function. It returns `None` if omitted. 

 

List Manipulation: 

`result.append(a)` adds the value of `a` to the `result` list. 

 

Method Calls: 

`result.append(a)` demonstrates calling a method (`append()`) on a list object (`result`). 

Function Renaming: 

Functions can be assigned to other names, like `f = fib`, allowing you to call them using the new name. 

 

None: 

Functions without a `return` statement return `None`. It's Python's way of representing no value. 

 

Efficiency: 

The `result.append(a)` method is more efficient than `result = result + [a]` for building lists. 

 

More on lists: 

`list.append(x)`: Add an item to the end of the list. 

`list.extend(iterable)`: Extend the list by appending items from an iterable. 

`list.insert(i, x)`: Insert an item at a given position. 

`list.remove(x)`: Remove the first occurrence of an item with a specific value. 

`list.pop([i])`: Remove and return an item at a given position or the last item if no index is specified. 

`list.clear()`: Remove all items from the list. 

`list.index(x)`: Find the index of the first item with a specific value. 

`list.count(x)`: Count the number of times a specific value appears in the list. 

`list.sort()`: Sort the list in place. 

`list.reverse()`: Reverse the list in place. 

`list.copy()`: Create a shallow copy of the list. 

 

These methods allow you to manipulate and work with lists efficiently. 

Using List as stack and queues: 

You can use a list as a stack for "last-in, first-out" operations by using `append()` to add items to the top and `pop()` to retrieve items from the top. 

 

For a queue with "first-in, first-out" operations, it's better to use `collections.deque` for efficiency. It provides fast appends and pops from both ends. 

 

Stack using list: 

A black screen with white text

Description automatically generated 

 

Queue using collections.deque: 

A black screen with white text

Description automatically generated 

 

Lists are not efficient for queues because inserting or popping from the beginning of a list is slow due to shifting elements. Use `collections.deque` for faster queue operations. 

List comprehensions: 

 

List comprehension provides a concise way to create lists in Python. They consist of an expression followed by a for clause and optional if. 

 

 

A black rectangle with colorful text

Description automatically generated 

 

A screenshot of a computer

Description automatically generated 

 

A screenshot of a computer program

Description automatically generated 

A black rectangle with colorful text

Description automatically generated 

 

A black and white screen with text

Description automatically generated 

 

A screen shot of a computer program

Description automatically generated 

 

Nested List Comprehensions: 

You can use list comprehensions for complex tasks, like transposing a matrix, but prefer built-in functions when possible. For transposing, use zip(): 

 

A screenshot of a computer code

Description automatically generated 

 

The del statement / Tuples and Sequences: 

In Python, you can use the del statement to remove items from a list by specifying their index or clear the entire list. For example: 

A screenshot of a computer

Description automatically generated 

Tuples are similar to lists but are immutable, meaning you can't change their elements after creation. They are often used for different purposes.  

Tuples are defined with parentheses, and they can be nested. You can use sequence unpacking to assign values from a tuple to variables: 

A screenshot of a computer

Description automatically generated 

Tuples with one item require a trailing comma to distinguish them from parentheses, like this: 

A black and white screen with white text

Description automatically generated 

Tuples are useful for situations where you want to ensure data remains unchanged, and sequence unpacking simplifies variable assignment from tuples. 

Sets: 

Python has a set data type that stores an unordered collection of unique elements. 

You can create a set using curly braces or the set () function. 

Sets are handy for membership testing and mathematical operations like union, intersection, difference, and symmetric difference. 

A black rectangular object with green text

Description automatically generated 

 

A screenshot of a computer program

Description automatically generated 

 

A black and white screen with text

Description automatically generated 

Dictionaries: 

Dictionaries are another data type in Python, used for key-value pairs.  

Dictionaries are created with curly braces or the dict() constructor.  

Keys must be unique, and you can store, extract, or delete values based on keys. Here's a quick overview. 

 

A screen shot of a computer

Description automatically generated 

 

A screenshot of a computer

Description automatically generated 

A screenshot of a computer

Description automatically generated 

 

Looping Techniques: 

You can loop through dictionaries using the items () method to get both the key and value simultaneously: 

A screen shot of a computer

Description automatically generated 

 

You can loop through sequences and get the index and value using enumerate(): 

A black screen with white text

Description automatically generated 

To loop over multiple sequences in parallel, use zip(): 

A screenshot of a computer screen

Description automatically generated 

For looping in reverse, use reversed(): 

A screen shot of a computer

Description automatically generated 

To loop over a sequence in sorted order, use sorted(): 

A computer screen with text on it

Description automatically generated 

Avoid modifying a list while looping over it, and consider creating a new list instead. For example, you can filter out NaN values from a list: 

A computer screen with text

Description automatically generated 

 

Comparing Sequences and Other Types: 

Sequence objects can be compared to other objects of the same type using lexicographical ordering. This means they are compared element by element, with the first differing element determining the outcome. 

If all elements are equal, the sequences are considered equal. 

 

Examples of comparisons: 

(1, 2, 3) < (1, 2, 4) 

[1, 2, 3] < [1, 2, 4] 

'ABC' < 'C' < 'Pascal' < 'Python' 

(1, 2, 3, 4) < (1, 2, 4) 

(1, 2) < (1, 2, -1) 

(1, 2, 3) == (1.0, 2.0, 3.0) 

(1, 2, ('aa', 

 

You can compare objects of different types if they have appropriate comparison methods. Otherwise, it raises a TypeError exception. 




Day4

In Python, classes are used to create objects, which are instances of the class. Classes provide a means of bundling data (attributes) and functionality (methods) together. Here's a basic overview of how classes work in Python:

Defining a Class: To define a class, you use the class keyword, followed by the class name and a colon. Class names in Python are typically written in CamelCase. Class Constructor and Instance Variables: The init method is a special method in Python classes and is used as a constructor. It is called when a new object of the class is instantiated. Instance variables are variables that belong to the object and are defined within the init method using the self keyword.

class MyClass: def init(self, var1, var2): self.var1 = var1 self.var2 = var2

Class Methods:
Methods are functions defined within a class. They can perform operations on the class's data or provide some functionality related to the class.

class MyClass: def init(self, var1, var2): self.var1 = var1 self.var2 = var2

def display_vars(self):
    print("Var1:", self.var1)
    print("Var2:", self.var2)
Creating an object of the class
obj = MyClass(10, 20) obj.display_vars()

Inheritance:
Inheritance allows one class to inherit properties and methods from another class. The derived class (subclass) inherits attributes and behaviors from the base class (superclass). class ParentClass: def init(self, var1, var2): self.var1 = var1 self.var2 = var2

class ChildClass(ParentClass): def init(self, var1, var2, var3): super().init(var1, var2) self.var3 = var3

ChildClass inherits from ParentClass. The super() function is used to call the constructor of the parent class within the child class.

Three important principles of object-oriented programming (OOP):
Encapsulation: Encapsulation is the bundling of data (attributes) and methods (functions) that operate on the data into a single unit known as a class. The data within a class is often kept private to prevent direct access from outside the class. Instead, access to the data is controlled through public methods, also known as getters and setters.
In Python, encapsulation is achieved by using private and public access specifiers. By convention, attributes prefixed with a single underscore (e.g., _variable) are considered protected, and attributes prefixed with double underscores (e.g., __variable) are considered private.

class MyClass: def init(self): self._protected_var = 10 # protected variable self.__private_var = 20 # private variable

def get_private_var(self):
    return self.__private_var
obj = MyClass() print(obj._protected_var) # Accessing protected variable (not recommended) #print(obj.__private_var) # This will raise an error (private variable) print(obj.get_private_var()) # Accessing private variable through a public method

2. Abstraction:
Abstraction is the process of hiding the complex implementation details and showing only the necessary features of an object. In Python, abstraction is achieved through abstract classes and interfaces. Abstract classes are classes that cannot be instantiated and are meant to be subclassed by other classes. Abstract methods defined in abstract classes must be implemented by their subclasses.

from abc import ABC, abstractmethod

class Shape(ABC): @abstractmethod def area(self): pass

class Square(Shape): def init(self, side): self.side = side

def area(self):
    return self.side * self.side
square_obj = Square(5) print(square_obj.area()) # Output: 25 #shape_obj = Shape() # This will raise an error (abstract class cannot be instantiated)

3. Polymorphism:
Polymorphism allows objects of different classes to be treated as objects of a common superclass. It enables flexibility and interchangeability of objects, making the code more modular and easier to maintain. Polymorphism is often achieved through method overriding and duck typing in Python. Method overriding occurs when a subclass provides a specific implementation for a method that is already defined in its superclass. This allows objects of different classes to be used interchangeably based on their common interface.

class Animal: def sound(self): pass

class Dog(Animal): def sound(self): return "Woof!"

class Cat(Animal): def sound(self): return "Meow!"

def print_animal_sound(animal): print(animal.sound())

dog = Dog() cat = Cat()

print_animal_sound(dog) # Output: Woof! print_animal_sound(cat) # Output: Meow!

In the example above, print_animal_sound() function can accept objects of different classes (Dog and Cat) because they share a common interface (the sound() method). This is an example of polymorphism in action.

These principles of object-oriented programming help in creating more organized, efficient, and maintainable code in Python and many other object-oriented programming languages.

Python Scopes and Namespaces
A namespace is a container that holds a set of identifiers (variable names, function names, class names, etc.) and their corresponding objects (values). A scope is a region of the program where a namespace is directly accessible. Understanding scopes and namespaces is crucial for writing Python code that behaves as expected, especially when dealing with variables and functions.

There are several types of namespaces and scopes in Python:

1. Local Namespace/Scope:
A local namespace is the namespace inside a function. It contains local variables, function arguments, and the function's name. This namespace is created when the function is called and is destroyed when the function exits. Local variables cannot be accessed from outside the function. examples:

def my_function(): local_var = 10 # This is a local variable print(local_var)

my_function()

print(local_var) # This will raise an error because local_var is not accessible here
2. Enclosing Namespace/Scope (Closure):
An enclosing namespace is the namespace of the containing (enclosing) function. It is accessible from nested functions. This allows inner functions to access variables from the outer (enclosing) function.

def outer_function(): outer_var = 20

def inner_function():
    print(outer_var)  # Accessing outer_var from the enclosing scope

inner_function()
outer_function() # Output: 20

3. Global Namespace/Scope:
The global namespace contains variables defined at the top level of the script or module. Global variables can be accessed from any part of the module or script. To modify a global variable inside a function, you need to use the global keyword

global_var = 30 # This is a global variable

def my_function(): global global_var global_var += 1 print(global_var)

4. Built-in Namespace/Scope:
The built-in namespace contains functions and names pre-defined in Python. Functions like print(), len(), and built-in types like list, dict are part of the built-in namespace.

my_function() # Output: 31 print(len([1, 2, 3])) # Output: 3

Classes and Variables
In object-oriented programming, class variables and instance variables are used to store data within classes. They serve different purposes and have different scopes.

Class Variables: Class variables are shared by all instances (objects) of a class. They are defined within a class but outside of any methods. Class variables are common to all instances of the class and are used to store data that is shared among all objects of that class.

class MyClass: class_variable = 0 # This is a class variable

def __init__(self, instance_variable):
    self.instance_variable = instance_variable  # This is an instance variable
Accessing the class variable
print(MyClass.class_variable) # Output: 0

Modifying the class variable
MyClass.class_variable = 10 print(MyClass.class_variable) # Output: 10

Creating instances of the class
obj1 = MyClass(5) obj2 = MyClass(8)

Accessing instance variables
print(obj1.instance_variable) # Output: 5 print(obj2.instance_variable) # Output: 8

above, class_variable is a class variable shared by all instances of MyClass. Changes made to the class variable are reflected in all instances.

Instance Variables:
Instance variables are specific to each instance of a class. They are defined inside the class methods, particularly within the class's constructor method (init). Instance variables are used to store data that is unique to each object created from the class.

In the example above, instance_variable is an instance variable. Each instance of MyClass can have a different value for instance_variable.

Instance variables are accessed and modified using the self keyword within class methods. Each instance of the class has its own copy of instance variables. class MyClass: def init(self, instance_variable): self.instance_variable = instance_variable # This is an instance variable

Creating instances of the class
obj1 = MyClass(5) obj2 = MyClass(8)

Accessing instance variables
print(obj1.instance_variable) # Output: 5 print(obj2.instance_variable) # Output: 8

class variables are shared among all instances of a class and are defined outside any methods, while instance variables are specific to each object and are defined within methods, usually in the constructor. Understanding the distinction between these types of variables is essential for effective object-oriented programming in Python.

RANDOM REMARKS
Data attributes override method attributes with the same name; to avoid accidental name conflicts, which may cause hard-to-find bugs in large programs, it is wise to use some kind of convention that minimizes the chance of conflicts. Possible conventions include capitalizing method names, prefixing data attribute names with a small unique string (perhaps just an underscore), or using verbs for methods and nouns for data attributes.

Data attributes may be referenced by methods as well as by ordinary users (“clients”) of an object. In other words, classes are not usable to implement pure abstract data types. In fact, nothing in Python makes it possible to enforce data hiding — it is all based upon convention. (On the other hand, the Python implementation, written in C, can completely hide implementation details and control access to an object if necessary; this can be used by extensions to Python written in C.)

random remarks and tips related to programming in Python and general software development:

Python's Readability: Python emphasizes readability and simplicity, making it a great language for beginners and experienced developers alike. The use of indentation to define blocks of code enhances code readability.

Use of Libraries: Python has a rich ecosystem of libraries and modules that can significantly speed up development. Whether you're working on web development, data analysis, machine learning, or any other domain, there's likely a Python library that can assist you.

Virtual Environments: It's good practice to use virtual environments (e.g., virtualenv or venv) for each of your Python projects. Virtual environments allow you to manage project-specific dependencies without interfering with system-wide Python packages.

Error Handling: Python provides robust error handling mechanisms using try, except, finally, and raise keywords. Proper error handling can make your code more reliable and user-friendly.

List Comprehensions: Python's list comprehensions provide a concise way to create lists. They can often replace traditional loops, making your code more compact and expressive.

example: # Traditional loop squares = [] for i in range(1, 6): squares.append(i**2)

Using list comprehension
squares = [i**2 for i in range(1, 6)]


